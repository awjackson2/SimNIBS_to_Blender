#!/usr/bin/env python3
"""
Convert SimNIBS mesh files with TI_max field data to PLY format for Blender.

This script reads .msh files generated by SimNIBS (with TI_max field data)
and converts them to PLY format that can be imported into Blender with
field values mapped to vertex colors.

Usage:
    python mesh_to_ply_converter.py input.msh output.ply
    python mesh_to_ply_converter.py --batch input_dir output_dir
    python mesh_to_ply_converter.py --field-range 0.0 1.0 input.msh output.ply
"""

import argparse
import os
import sys
import numpy as np
from pathlib import Path
import logging

try:
    import simnibs
    from simnibs import read_msh
except ImportError:
    print("Error: SimNIBS not found. Please install SimNIBS and activate the environment.")
    sys.exit(1)

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def write_ply_with_colors(vertices, faces, colors, output_path, field_name="TI_max"):
    """
    Write mesh data to PLY format with vertex colors.
    
    Parameters:
    -----------
    vertices : np.ndarray
        Vertex coordinates (N x 3)
    faces : np.ndarray  
        Triangle indices (M x 3)
    colors : np.ndarray
        RGB colors for each vertex (N x 3), values 0-255
    output_path : str
        Output PLY file path
    field_name : str
        Name of the field being visualized
    """
    n_vertices = len(vertices)
    n_faces = len(faces)
    
    with open(output_path, 'w') as f:
        # PLY header
        f.write("ply\n")
        f.write("format ascii 1.0\n")
        f.write(f"comment Generated from SimNIBS mesh with {field_name} field\n")
        f.write(f"element vertex {n_vertices}\n")
        f.write("property float x\n")
        f.write("property float y\n") 
        f.write("property float z\n")
        f.write("property uchar red\n")
        f.write("property uchar green\n")
        f.write("property uchar blue\n")
        f.write(f"element face {n_faces}\n")
        f.write("property list uchar int vertex_indices\n")
        f.write("end_header\n")
        
        # Write vertices with colors
        for i in range(n_vertices):
            x, y, z = vertices[i]
            r, g, b = colors[i].astype(int)
            f.write(f"{x:.6f} {y:.6f} {z:.6f} {r} {g} {b}\n")
        
        # Write faces
        for face in faces:
            f.write(f"3 {face[0]} {face[1]} {face[2]}\n")


def write_ply_with_scalars(vertices, faces, scalars, output_path, field_name="TI_max"):
    """
    Write mesh data to PLY format with scalar field values.
    
    Parameters:
    -----------
    vertices : np.ndarray
        Vertex coordinates (N x 3)
    faces : np.ndarray
        Triangle indices (M x 3) 
    scalars : np.ndarray
        Scalar values for each vertex (N,)
    output_path : str
        Output PLY file path
    field_name : str
        Name of the field being stored
    """
    n_vertices = len(vertices)
    n_faces = len(faces)
    
    with open(output_path, 'w') as f:
        # PLY header
        f.write("ply\n")
        f.write("format ascii 1.0\n")
        f.write(f"comment Generated from SimNIBS mesh with {field_name} field\n")
        f.write(f"element vertex {n_vertices}\n")
        f.write("property float x\n")
        f.write("property float y\n")
        f.write("property float z\n")
        f.write(f"property float {field_name}\n")
        f.write(f"element face {n_faces}\n")
        f.write("property list uchar int vertex_indices\n")
        f.write("end_header\n")
        
        # Write vertices with scalar values
        for i in range(n_vertices):
            x, y, z = vertices[i]
            scalar_val = scalars[i]
            f.write(f"{x:.6f} {y:.6f} {z:.6f} {scalar_val:.6f}\n")
        
        # Write faces
        for face in faces:
            f.write(f"3 {face[0]} {face[1]} {face[2]}\n")


def field_to_colormap(field_values, colormap='viridis', vmin=None, vmax=None):
    """
    Convert field values to RGB colors using a colormap.
    
    Parameters:
    -----------
    field_values : np.ndarray
        Field values to map to colors
    colormap : str
        Matplotlib colormap name
    vmin, vmax : float
        Value range for color mapping
        
    Returns:
    --------
    np.ndarray
        RGB colors (N x 3) with values 0-255
    """
    try:
        import matplotlib.pyplot as plt
        import matplotlib.cm as cm
    except ImportError:
        logger.warning("Matplotlib not available, using simple blue-red colormap")
        return simple_colormap(field_values, vmin, vmax)
    
    # Normalize field values
    if vmin is None:
        vmin = np.nanmin(field_values)
    if vmax is None:
        vmax = np.nanmax(field_values)
    
    if vmax == vmin:
        # All values are the same
        normalized = np.zeros_like(field_values)
    else:
        normalized = (field_values - vmin) / (vmax - vmin)
        normalized = np.clip(normalized, 0, 1)
    
    # Apply colormap
    cmap = cm.get_cmap(colormap)
    colors_rgba = cmap(normalized)
    
    # Convert to RGB 0-255
    colors_rgb = (colors_rgba[:, :3] * 255).astype(np.uint8)
    
    return colors_rgb


def simple_colormap(field_values, vmin=None, vmax=None):
    """
    Simple blue-to-red colormap without matplotlib dependency.
    """
    if vmin is None:
        vmin = np.nanmin(field_values)
    if vmax is None:
        vmax = np.nanmax(field_values)
    
    if vmax == vmin:
        # All values the same - use blue
        colors = np.zeros((len(field_values), 3), dtype=np.uint8)
        colors[:, 2] = 255  # Blue
        return colors
    
    # Normalize 0-1
    normalized = (field_values - vmin) / (vmax - vmin)
    normalized = np.clip(normalized, 0, 1)
    
    # Simple blue to red mapping
    colors = np.zeros((len(field_values), 3), dtype=np.uint8)
    colors[:, 0] = (normalized * 255).astype(np.uint8)  # Red channel
    colors[:, 2] = ((1 - normalized) * 255).astype(np.uint8)  # Blue channel
    
    return colors


def convert_mesh_to_ply(input_path, output_path, field_name="TI_max", 
                       use_colors=True, colormap='viridis', 
                       field_range=None, tissue_types=None):
    """
    Convert SimNIBS mesh file to PLY format.
    
    Parameters:
    -----------
    input_path : str
        Input .msh file path
    output_path : str
        Output .ply file path
    field_name : str
        Name of field to extract and visualize
    use_colors : bool
        If True, map field values to vertex colors. If False, store as scalars.
    colormap : str
        Matplotlib colormap name for color mapping
    field_range : tuple
        (min, max) range for field value mapping
    tissue_types : list
        List of tissue types to include (default: cortical tissues)
    """
    logger.info(f"Converting {input_path} to {output_path}")
    
    # Read mesh
    try:
        mesh = read_msh(input_path)
        logger.info(f"Loaded mesh with {len(mesh.nodes.node_coord)} nodes and {mesh.elm.nr} elements")
    except Exception as e:
        logger.error(f"Failed to read mesh {input_path}: {e}")
        return False
    
    # Filter by tissue type if specified
    if tissue_types is None:
        # Include all triangles
        triangles = mesh.elm[mesh.elm.elm_type == 2]  # All triangles
    else:
        # Find triangles of the specified tissue types
        triangle_mask = np.isin(mesh.elm.tag1, tissue_types)
        triangles = mesh.elm[triangle_mask]
        
        if len(triangles) == 0:
            logger.warning(f"No triangles found with tissue types {tissue_types}")
            # Fall back to all triangles
            triangles = mesh.elm[mesh.elm.elm_type == 2]  # All triangles
    
    if len(triangles) == 0:
        logger.error("No triangles found in mesh")
        return False
    
    logger.info(f"Found {len(triangles)} triangles")
    
    # Get triangle node indices (convert to 0-based)
    if hasattr(triangles, 'node_number_list'):
        # triangles is an Elements object
        triangle_nodes = triangles.node_number_list[:, :3] - 1
    else:
        # triangles is a numpy array from node_number_list (node1, node2, node3, -1)
        # Take the first three columns and ignore the -1
        triangle_nodes = triangles[:, :3] - 1
    
    # Get unique nodes and remap indices
    unique_nodes = np.unique(triangle_nodes.flatten())
    node_map = {old_idx: new_idx for new_idx, old_idx in enumerate(unique_nodes)}
    
    # Extract vertex coordinates
    vertices = mesh.nodes.node_coord[unique_nodes]
    
    # Remap triangle indices
    faces = np.array([[node_map[idx] for idx in triangle] for triangle in triangle_nodes])
    
    logger.info(f"Extracted {len(vertices)} vertices and {len(faces)} faces")
    
    # Extract field data
    field_data = None
    if hasattr(mesh, 'nodedata') and len(mesh.nodedata) > 0:
        # Look for the specified field
        field_idx = None
        for i, nodedata in enumerate(mesh.nodedata):
            if hasattr(nodedata, 'field_name') and nodedata.field_name == field_name:
                field_idx = i
                break
        
        if field_idx is not None:
            field_data = mesh.nodedata[field_idx].value[unique_nodes]
            logger.info(f"Found field '{field_name}' with range [{np.min(field_data):.6f}, {np.max(field_data):.6f}]")
        else:
            logger.warning(f"Field '{field_name}' not found. Available fields: {[nd.field_name for nd in mesh.nodedata if hasattr(nd, 'field_name')]}")
    
    if field_data is None:
        logger.warning("No field data found, creating mesh without field visualization")
        # Create default colors (gray)
        if use_colors:
            colors = np.full((len(vertices), 3), 128, dtype=np.uint8)
            write_ply_with_colors(vertices, faces, colors, output_path, field_name)
        else:
            scalars = np.zeros(len(vertices))
            write_ply_with_scalars(vertices, faces, scalars, output_path, field_name)
    else:
        # Process field data
        vmin, vmax = field_range if field_range else (None, None)
        
        if use_colors:
            colors = field_to_colormap(field_data, colormap, vmin, vmax)
            write_ply_with_colors(vertices, faces, colors, output_path, field_name)
        else:
            write_ply_with_scalars(vertices, faces, field_data, output_path, field_name)
    
    logger.info(f"Successfully wrote PLY file: {output_path}")
    return True


def batch_convert(input_dir, output_dir, field_name="TI_max", **kwargs):
    """
    Batch convert all .msh files in a directory to PLY format.
    """
    input_path = Path(input_dir)
    output_path = Path(output_dir)
    
    if not input_path.exists():
        logger.error(f"Input directory does not exist: {input_dir}")
        return
    
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Find all .msh files
    msh_files = list(input_path.glob("*.msh"))
    
    if not msh_files:
        logger.warning(f"No .msh files found in {input_dir}")
        return
    
    logger.info(f"Found {len(msh_files)} mesh files to convert")
    
    success_count = 0
    for msh_file in msh_files:
        output_file = output_path / (msh_file.stem + ".ply")
        
        if convert_mesh_to_ply(str(msh_file), str(output_file), field_name, **kwargs):
            success_count += 1
    
    logger.info(f"Successfully converted {success_count}/{len(msh_files)} files")


def main():
    parser = argparse.ArgumentParser(description="Convert SimNIBS mesh files to PLY format for Blender")
    
    parser.add_argument("input", help="Input .msh file or directory")
    parser.add_argument("output", help="Output .ply file or directory") 
    parser.add_argument("--field", default="TI_max", help="Field name to extract (default: TI_max)")
    parser.add_argument("--batch", action="store_true", help="Batch convert all .msh files in input directory")
    parser.add_argument("--scalars", action="store_true", help="Store field as scalars instead of colors")
    parser.add_argument("--colormap", default="viridis", help="Colormap for field visualization (default: viridis)")
    parser.add_argument("--field-range", nargs=2, type=float, metavar=("MIN", "MAX"), 
                       help="Field value range for color mapping")
    parser.add_argument("--tissues", nargs="+", type=int, 
                       help="Tissue types to include (default: cortical surfaces)")
    
    args = parser.parse_args()
    
    kwargs = {
        'field_name': args.field,
        'use_colors': not args.scalars,
        'colormap': args.colormap,
        'field_range': tuple(args.field_range) if args.field_range else None,
        'tissue_types': args.tissues
    }
    
    if args.batch:
        batch_convert(args.input, args.output, **kwargs)
    else:
        convert_mesh_to_ply(args.input, args.output, **kwargs)


if __name__ == "__main__":
    main() 